# 外设与内存

> 本文主要讨论minitinyMIPS如何访问外设与内存。

冯诺依曼机由五大部件构成，运算器/数据通路，控制器，存储器，输入输出。本讲主要讨论存储器与输入输出。

本讲的前半部分主要是一些理论知识，介绍内存与外设的访问，并具体针对于mtMIPS的内存与外设系统进行讨论。

在软件程序当中，有着各种各样的简单变量，也有着复杂的数据结构——数组与结构体，这些数据都存放于内存当中。处理器如何访问如此多样复杂的数据呢？

现代的几乎所有的ISA都被划分到了通用寄存器体系结构中。这种指令集架构以通用计算器堆作为运算的中心，数据的来源要么来自于通用寄存器，要么来自于内存。这一分类下的ISA可以被进一步分类，一种是**register-memory ISA**，以x86体系结构为例，其指令集中的很多指令都可以访问寄存器堆，比方说mov指令可以直接将数据从内存当中移动到内存，add指令可以直接将内存数据作为操作数。另一种是**load-store ISA**,这种架构只允许load store指令对存储器进行访问，通过这些指令将数据从内存中加载到寄存器堆当中进行进一步的运算。本课程中使用的MIPS指令集，以及RISC-V指令集，ARM指令集，LoongArch指令集都属于这一类。

> 其实翻阅计算机的发展历史，通用寄存器体系结构并非处理器的

MIPS仅允许load，store指令访问存储器，但是它有非常多的load，store指令。

根据要访问的数据宽度，存储指令store分为`sw`、`sh`、`sb`，分别从内存中写入大小为4字节（**w**ord），2字节（**h**alf word），1字节（**b**yte），对于MIPS64架构中还有`sd`指令（**d**ouble word）。

load指令略有不同，一个小于寄存器宽度的数据（比如half word和byte），载入寄存器后，应该以符号扩展的方式载入还是有符号扩展的方式西载入呢？基于这个属性，load指令比store指令有着更多的分类。包括`lw`,`lh`,`lb`,`lhu`,`lbu`等指令。u的后缀代表unsigned，无符号，意味着当从内存中载入这一一个小于机器字长（寄存器宽度）的数据时，应当采用无符号扩展。相应的没有u后缀的会将从内存中读回的数据进行有符号扩展。

## 外设访问

输入输出，是处理器的另外一个重要功能。在讨论输入输出之前，我们首先需要讨论，什么是设备呢？设备同样也是一个数字电路，其中包含着状态单元，这些状态单元事实上就是设备赖以运行的数据与控制信号。

日常生活中的设备有很多，显示器是设备，鼠标键盘是设备，硬盘控制器也是设备。这些设备与CPU进行着数据交互与控制交互。CPU通过为设备发送数据和控制信号指导设备工作，CPU通过从读设备获取数据。CPU对设备的控制事实上就是通过某种方式访问到设备的上的控制寄存器，设备会对控制寄存器中的信息进行译码解析，指导着设备的运行。所以外设的访问与内存访问是类似的，从某个地方读取数据，向某个地方写入数据。

而如何找到要读取和写入的地方，找到对应的寄存器，就是IO编址的问题。

一种方案是，将外设视为一种特殊的存在，通过独立的编址空间对其进行编址，通过独立的指令对其进行访问，这种方式称为PMIO（port-mapped I/O），例如x86就采用了这种方式，利用IN/OUT指令，通过指定端口号访问到对应的设备。

另一种方案是，不区分访存与访问外设，内存与外设统一进行编址，采用访存指令访问外设，这种方式称为MMIO方式（memory mapped I/O）。这种方式相当于将对内存地址空间某段的访问进行转发，转发到外设的地址空间上去。MIPS架构就采用这种方式，因此，对于外设的访问也同样采用前文提到load store指令进行。

## mtMIPS的访存与外设系统

mtMIPS的整体结构图如下图所示。可以看到，CPU的访存需求一共有两类，一类是指令的访存请求，一类是数据的访存请求。其中，数据的访存请求被连接到了Router模块。Router模块相当于一个总线控制器，总线上挂载着设备SimDevice，和内存Memory，Router需要根据访存的地址确认具体的访存请求时发送到设备还是内存，给对应模块发起访存请求。下面我们分别介绍访存系统中的三个模块的基本功能。

![img](mem_device.assets/Top.jpg)

### Memory模块

Memory模块是一个内存模块，由于处理器每个周期最多会进行一次数据访存和一次指令访存，如果我们设计的存储器只有一个端口，就会导致处理器执行load指令时出现停顿，因为当前指令的取指和访存请求同时到达，而读口只有一个，一个周期内只能处理一条指令，这就会导致该任务无法在单周期内完成。

本设计当中，设置了两个读口，分别支持指令访存和数据访存。同时仅设计了一个写口，因为只有数据访存会有写入的请求。

Memory是一个单周期返回结果的存储器，其设计类似于处理器的寄存器堆。

!> 关于Memory的写入，当前的设计并不支持根据wstrb写入Memory的对应位，如果你需要实现`sb`指令和`sh`等指令，你需要对Memory的模块进行修改，增加对于写掩码的支持，框架中已经给出部分代码。

### SimDevice

SimDevice是一个模拟串口的外设，当Router对其发起写入请求时，它会检测输入的地址，如果地址是模拟串口的地址，就会调用fwrite函数将输入的数据以ASCII码打印出来。

### Router

Router可以看作一个简单的总线控制器，挂载在其上的设备统一连接到总线的数据信号上，包括`common_addr`，`common_rdata`，`common_wdata`,`common_wstrb`,这些信号连接在挂载在总线上的每一个设备上。但是对于每个设备，有着额外的控制信号，控制读写操作的使能，比如device有着其独立的控制信号`device_wen`和`device_ren`。router的主要工作也就是根据CPU发送的地址，给这些独立的控制信号以使能。

MIPS中留给外设的地址段，0xa0000000-0xbfffffff的，因此router可以通过地址高位对CPU发来的访存请求进行判断，将落在0xa0000000-0xbfffffff的访存请求，发给SimDevice，将对应`device_wen`和`device_ren`置为使能。在其他时候则信号置为0

!> 注意，发给设备的请求不能再同时发给内存，请注意修改内存的控制信号

---

## 访存实验说明

为了让大家简单的试用虚拟串口，我们在asm-test中给出了一段可以输出Hello-world的汇编代码，大家可以通过运行这段汇编代码，从而让处理器通过虚拟串口输出Hello，world

为了完成这个实验，在处理器核部分完成的六个实验的基础上，你还需要以下部分的修改

* 将asm-test中的文件进行编译，获取对应的`mem.data`文件，具体参考[环境使用指导](/miniminimips/env)

	> 如果实验环境上有困难可以考虑找同学要一份。

* 修改Router，正确的给出访存指令

* 实现lui指令，ori指令

  > 为什么需要lui指令和ori指令呢，因为asm-test需要首先将串口的地址0xa00003f8加载到寄存器当中，汇编代码中使用了li伪指令，但是该指令在载入串口地址时，会被拆分成lui和ori两条指令，因此需要实现这两天指令才能正确将地址加载到寄存器当中进行后面的访存
