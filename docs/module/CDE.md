## CDE环境介绍与指令扩展

?>任务: 请阅读《计算机组成原理课程设计指导书 上》的讲义三，了解CDE工程的代码结构。

?>任务: 请阅读《计算机组成原理课程设计指导书 下》的第二章，第三章，学习TinyMIPS的处理器结构，并选择若干条指令进行扩展，以加深对TinyMIPS的理解

### TinyMIPS中一条指令的执行过程——指令扩展方法简述

#### TinyMIPS中功能部件

TinyMIPS采用了经典的五级流水线会将一条指令的执行划分成5个阶段，IF(Instruction Fetch, 取指), ID(Instruction Decode, 译码), EX(Execute, 执行), MEM(Memory, 访存), WB(Write Back, 写回)。处理器核的代码位于CDE目录下的`cpu/core`中，包括五级流水线每一级的代码和级间寄存器的代码。本讲不涉及流水线前递与暂停等部件的介绍。

`IF`阶段，其功能是将PC发给存储器，从存储器中读取指令。对应着单周期处理器中的IFU，主要区别在于TinyMIPS中的存储器不在位于核内。

?>  IF阶段会通过ROM接口，访问到外部分存储器，可以看到，代码中，PC的复位值是 \`INIT_PC - 4，原因是什么？阅读 《计算机组成原理课程设计实验指导书 上》了解相关内容

`ID`阶段，其功能是根据指令进行译码，生成控制信号，读取操作数。这个部分对应着单周期处理器实验中的Control模块，为了便于理解，TinyMIPS将模块拆分为了5个部分。分别是FunctGen，生成ALU的控制信号, BranchGen，生成PC跳转的控制信号, OprandGen，生成ALU进行运算操作数， RegGen，生成对寄存器堆的控制信号， MemGen，生成对存储器的控制信号。

`EX`阶段，根据操作数计算出结果，对应单周期处理器中的ALU

`MEM`阶段，访存并读取访存结果。同样的，由于TinyMIPS的存储器位于核外，在这个模块中主要用于生成对存储器的控制信号。访存模块为了适应总线，每次访问的区域总是在一个4字节对齐的空间上，比如说通过LB指令访问0x80000001处的地址，事实上是访问0x80000000处的一块4字节空间，通过ram_write_sel/ ram_read_sel 进行读写选择，写入特定的位置。

`WB`阶段，主要负责更新处理器的通用寄存器状态。

寄存器堆，MIPS提供了32个通用寄存器，其中要求0号寄存器始终为0

?> 0号寄存器始终为0是如何实现的？阅读TinyMIPS的实现方法，并思考一下，是否有其他的实现方式。

级间寄存器通过一个个DFF实现，对于每个信号，都有一个独立的DFF实现 ，每个DFF采用一个成为PipelineDeliver的模块实现。这个模块是一个参数化的模块，对于不同的信号，会实例化不同位宽的DFF。对于其中的控制信号，将会在处理器冒险部分进行介绍。

#### 指令扩展示例——以BEQ指令的执行过程为例

!> 对于个人任务要求的22条指令指令，不需要再增加任何的模块

在充分理解了TinyMIPS这一系列功能部件的作用后，就可以尝试参考其他指令的实现，如法炮制，完成自己的指令的扩展。以下简单分析一下BEQ指令的执行过程，希望能够帮助大家了解指令扩展过程的方法。

首先我们审视一下，TinyMIPS中，BEQ指令在指令执行的各个阶段需要做什么。

首先是访存阶段，该阶段跟一般的指令一样，只是需要将这条指令取出来。

然后是译码阶段，译码阶段主要有五个方面的工作：RegGen模块生成对寄存器堆的控制信号，BEQ指令的功能是比较两个寄存器的值，判断是否相等，所以首先需要访问两个寄存器。需要在RegGen中生成相应的使能信号，需要读两个寄存器，但是不需要写寄存器堆；OprandGen主要是生成ALU操作数，BEQ指令不需要用到ALU，而是ID阶段的BranchGen判断指令跳转情况，该模块中设置了额外的加法器，用于计算跳转地址，判断跳转方向。MemGen模块，FunctGen则不需要考虑，因为用不到Mem和ALU

对于EX和MEM阶段，没有执行任务，所以只需要按照默认状态去进行即可。

这里给出这样的一个分析示例，在扩展过程中，主要是希望大家能够聚焦于各个模块的功能，体会一条指令执行过程中需要经历的各个阶段，理解每个阶段的功能，从而掌握指令的扩展方法。

### 处理器的验证

验证（Verification）是指通过提供客观证据对规定要求已得到满足的认定。在通用处理器的开发当中，我们的验证工作主要就是验证处理器行为是否符合指令集架构规范。

我们再次回到处理器的状态机模型，回想一下，状态机的正确性需要如何验证？状态机是有若干状态和若干状态转换关系构成的，我们只需要验证ISA可见的处理器状态在一条指令的执行后能够正确的变换到下一个状态，换言之，寄存器，内存得到正确的修改。我们计组课设所采用的验证方式也基于这种思路。

CDE环境中提供了称为Trace比对的验证机制。Trace的基本思路是，我们提供一个正确的CPU模型，让我们的待测模型与这个正确的模型进行对比：两个处理器执行相同的指令，比较其对通用寄存器的修改情况。这个正确的模型是龙芯公司的GS132处理器，由其运行一系列指令序列，生成trace记录。然后对处理器进行仿真，将所有对通用寄存器堆进行修改的指令进行对比，判断是否正确的修改了处理器状态。如果出现了不一致的情况，就意味着处理器的实现出现了问题，会立刻停止仿真。

?> 阅读代码mycpu_tb.v，尝试理解Trace比对的机制。

