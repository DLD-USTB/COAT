## 中断异常

在一个处理器的运行过程中，指令流的变化往往按照指令正常的顺序执行或是发生跳转，然而某些时候，会存在着一些需要中断当前任务，切换到其他流程的场景。触发这样的切换的事件被称之为异常（在龙芯的文档里一般称例外）。

异常的来源有很多，包括外部的中断事件，内部的自陷指令，以及存在某些指令的执行不符合指令集规范，这些都会触发异常。

虽然异常的名字听起来似乎不是什么好东西，但事实上，今天的计算机世界不能没有异常机制的存在。

以与处理器共同成长的操作系统为例，操作系统的诸多功能都需要硬件异常机制支持。用户程序在操作系统上运行时，某些时候需要从用户态**陷入**到内核态，执行一些只有操作系统才能执行的特权指令，又比如，在操作系统调度时，往往会在一个或多个时钟中断被触发时做出调度决策。操作系统对于外设的管理同样也需要异常机制的支持——某个外设向操作系统发出信号，告诉操作系统有外部事件值得被留意，需要操作系统做出相应的响应。

> 需要指出，在计组课设中，所有的程序都运行在核心态模式（Kernel Mode），特权级最低（靠近底层），权力最大，可以执行CPU所支持的任意指令，访问任意的地址空间。

异常机制同时还负责向上层软件报告指令可能的运行错误，比如访存地址不对齐，溢出现象，这种情况下可能无法得到软件所期望的结果，硬件通过异常机制向软件发出警告，让上层软件裁定该如何处理该结果。

异常机制作为处理器的重要概念，是TinyMIPS处理器扩展中所关注的一个重要的方向。理解异常与异常处理机制，也能帮助大家更好的理解操作系统课程的相关知识，更好的理解计算机系统的软硬件协同机制。

> MIPS架构中所涉及的异常种类参见*Appendix——A02“系统能力培养大赛”MIPS指令系统规范v1.00*

### 异常分类

异常大致可以分为同步异常和异步异常——中断。计组课设中MIPS需要支持的异常一共有6种，列举如下

* Int: Interrupt
* AdEL/AdES: Address error exception (load or instruction fetch) / Address error exception (store)
* Ov: Arithmetic Overflow exception
* Sys/Bp/RI :System Call Exception/Breakpoint exception/ Reserved Instruction

保留指令异常（RI）表示出现了非法的指令，当执行一条未被实现的指令会触发相应的异常。

Syscall和Break指令分别会触发系统调用异常(Sys)，断点异常(Bp)，因为这些指令执行后，在多特权级的情形下，会从当前特权级陷入更底层的特权级，由于这种异常行为是指令主动触发，所以这些指令称为自陷指令。

### MIPS CP0协处理器

协处理器一词听起来非常高级，~~听起来难度相当于实现0.5个TinyMIPS~~。事实上协处理器是有一系列寄存器和其读写控制逻辑组合而成的一个稍微高级一些的寄存器堆，其中的寄存器反映着处理器运行的状态，也是上层软件对于处理器行为的控制接口。CP0寄存器与通用寄存器，PC寄存器一样，同属于ISA级处理器状态的一部分，程序员可见。

在本课程要求实现的MIPS指令集中，CP0协处理器中共有6个寄存器，分别是 `BadVAddr`,`Count`,`compare` `Status`,`Cause`,`EPC`，其中

* `BadVaddr`是一个软件只读的寄存器，对该寄存器的写入工作仅有硬件来完成，其触发条件包括

  * Address error (AdEL or AdES) 

    > AdEL:  Address error exception (load or instruction fetch)
    >
    > AdES：Address error exception (store)

  * TLB Refill 

  * TLB Invalid (TLBL, TLBS) 

    > TLB exception (load or instruction fetch)
    >
    > TLB exception (store)

  * TLB Modified

  考虑到当前并不需要实现TLB（但欢迎大家实现），只需要实现关于地址错相关的处理即可

* `Count`是一个软件可读写的寄存器。`Count`的数值以固定频率增加，这一行为不受CPU中执行的指令的影响，无论流水线发生暂停或是刷新，`Count`寄存器时钟以固定频率单调增加，在计组课设的要求中，每两个时钟周期，`Count`值增加1（具体参考*Appendix——A02“系统能力培养大赛”MIPS指令系统规范v1.00*）

* `Compare` 寄存器 是一个可读写寄存器，`Compare` 寄存器所存放的值在写入后保持不变，与 `Count` 寄存器的低 32 位进行比较，当两者相等时则触发计时器中断

  > 定时器中断默认并不要求实现

* `Status`是一个软件可读写的寄存器。其中包括了

  * 中断屏蔽位`IM7`..`IM0`，若`IMx`为0，则`Cause`当中的`IPx`位不生效，
  * 例外级EXL
  * 全局中断使能位IE
  * 该寄存器的具体功能与布局请参考*Appendix——A02“系统能力培养大赛”MIPS指令系统规范v1.00*

* `Cause` 寄存器主要用于描述最近一次例外的原因。除了 IP1..IP0 域外， `Cause`寄存器的其它域对于软件均只读。`Cause`寄存器上包括IP7-IP0共8个中断位，该位置1表示该位存在待处理中断。IP1..IP0软件可写，通过对这两位进行写入就可以实现软件中断。IP7一般连接定时器中断。同时IP7-IP2对应外部的6个中断。请参考*Appendix——A02“系统能力培养大赛”MIPS指令系统规范v1.00*

  * 关于定时器中断的处理，龙芯的指令集手册说明不甚详细，此处补充介绍如下，Cause寄存器的TI位代表了存在尚未处理器的时钟中断，换言之，TI位应当在定时器中断触发时置1，直到相关操作对TI位进行清零才可以重新置为0。而IP7会对TI位进行采样和外部中断同时采样，当该位使能时触发中断。TI位会在写入动作发生时清零，尽管该位并不可写。


作为程序员可见的寄存器，程序员可以对其进行读写，该操作通过指令`mfc0`,`mtc0`实现，即Move from CP0和Move to CP0。这些指令必须在最高控制权的核心态下才能使用，所以称为特权指令。

### 异常处理流程

当出现异常时，处理器将会有相应的行为，从状态机视角来看，处理器的各个状态寄存器和PC都会发生变换。具体而言会按照以下流程变化（以下内容来自指令集手册）

> (1) 当 CP0.Status.EXL 为 0 时，更新 CP0.EPC：将例外处理返回后重新开始执行的指令 PC 填入到 CP0.EPC 寄存
> 器寄存器中。如果发生例外的指令不在分支延迟槽中，则重新开始执行的指令 PC 就等于发生例外的指令
> 的 PC；否则重新开始执行的指令 PC 等于发生例外的指令的 PC-4（即该延迟槽对应的分支指令的 PC）
> (2) 当 EXL 为 0 时，更新 CP0.Cause 寄存器的 BD 位：如果发生例外的指令在分支延迟槽中，则将
> CP0.Cause.BD 置为 1。
> (3) 更新 CP0.Status.EXL 位：将其置为 1。
> (4) 进入约定的例外入口重新取指，软件开始执行例外处理程序。
> 当软件完成例外处理程序的执行后，通常会使用 ERET 指令从例外处理程序返回，ERET 指令的作用是：
> (1) 将 CP0.Status.EXL 清零。
> (2) 从 CP0.EPC 寄存器取出重新执行的 PC 值，然后从该 PC 值处继续取指执行。

简而言之，就是当异常发生时，修改PC到异常入口，在Cause寄存器种记录异常的原因，将发生异常的PC记录在EPC寄存器中，记录其他必要信息。

在中断处理的过程中EXL置1，此时不处理其他任何中断和异常。异常处理的返回依靠ERET指令。ERET指令同样是特权指令。

#### 异常入口

对于x86架构中，当触发异常时，会根据异常号，在IDT（IDT(Interrupt Descriptor Table, 中断描述符表）中查找到对应的异常程序的入口地址。

对于计组课设要求的MIPS架构，异常程序的地址是统一的，都位于0xBFC0.0380，当触发异常时会跳转到该地址。

### 精确异常

对于流水线处理器来说，一条指令的执行分为多个阶段。发生异常时，意味着要进行异常处理，也就是要更新PC，修改寄存器状态，这个工作应该在何时进行呢？

一种思路是何时检测出异常何时进行异常处理。例如Syscall指令，Break指令，他们都可以在ID阶段检测到出现异常，而比如地址不对齐导致的地址错例外可能发生于MEM级。如果我们在检测到异常指令，会出现何种问题呢？

试想下面的指令序列，有一条访存指令，该访存指令访问的地址不对齐，其后跟上了一条syscall指令，如下图所示

![image-20221012201559958](module\module.assets\image-20221012201559958.png)

时序上ID级异常先被发现，这样就会出现我们先处理ID级的异常。这也就违背了我们向ISA承诺的**顺序执行指令**，不符合ISA提供的处理器模型。

为了确保异常处理符合ISA规范，我们提出`精确异常`的概念。当异常发生时，异常指令前的指令全部执行，异常之后的指令全不执行。这样就能确保指令对处理器的修改符合ISA的顺序执行指令的要求。

为了实现精确异常，我们的策略是，在指令执行的某个特定阶段进行异常处理，这样异常指令前的指令都已经经过了提交异常的阶段，异常指令后的指令都尚未到达这一阶段。那么应该选择哪一个阶段呢？如果我们选择ID级，我们就永远没办法检测到EX和MEM级的异常，所以应该选择一个后面再也没有异常的流水级，因此MEM级和WB级都是合适的选择。

?> 思考，如果异常处理的流水级选择在了WB级，此时如果说产生异常指令之后的指令是一条写内存指令，在发现异常的同时MEM级就会发出写内存请求，这应该如何处理呢？更进一步，如果我们的写入内存请求放在了EX级呢？

### 中断处理

#### 中断产生

参见*Appendix——A02“系统能力培养大赛”MIPS指令系统规范v1.00*

#### 中断与流水线

前面已经说过，中断又被称为异步异常，我们应该何时进行中断的异常处理呢？

其他异常与指令一一对应，然而中断则不然。既然中断本身不存在这种对应关系，我们就自己建立此种对应关系，当中断产生时，我们会标记当前在流水线中运行的某条指令，将其标记为中断指令，该指令就如同一般的异常指令一样，在异常的提交阶段进行异常处理。这样，中断这种特殊例外便与其他的异常处理流程一致。

在这里需要注意软中断与自陷的区别，软中断通过CP0寄存器的访问指令产生中断，与该写CP0的指令是异步的，而自陷指令的异常处理，是与该指令同步的。所以二者并不能等同。

?> 基本任务：按照《计算机组成原理课程设计实验指导书补充内容》的指导，实现相关异常处理

?> 扩展任务：实现本文档中介绍的所有异常，通过测试用例的89个功能点。
