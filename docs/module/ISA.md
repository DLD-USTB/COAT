## MIPS指令集架构与MIPS汇编

计组课设中，采用的是MIPS指令集，大家需要在本实验中，实现MIPS指令集架构中的若干指令。这里简单的介绍一下MIPS指令集架构的一些基础知识。

### MIPS指令集架构

MIPS架构，全称Microprocessor without Interlocked Piped Stages architecture。MIPS作为自RISC的概念被提出后的几十年内，最为经典的精简指令集架构，被许多的教材广泛采纳，用于组成原理的体系结构的教学当中，其。（近十年随着RISC-V架构发展，很多经典书目的新版本都转向采用RISC-V作为RISC指令集的典范）。
> MIPS同时也是Million Instructions Per Second的缩写，该单位往往用来衡量处理器的吞吐量

MIPS架构可以分称MIPS64，MIPS32等，计组课设当中要求实现的指令集是MIPS32指令集的裁剪后的版本,为了方便下文提到MIPS都特指计组课设中要求实现的裁剪后的MIPS32指令集。

MIPS中的指令长度为32位，指令大致可以归为`I-Type`，`R-Type`，`J-Type`,其中包括了算数运算指令，逻辑运算指令，移位运算指令，分支跳转指令，直接跳转指令，访存指令，自陷指令等。本实验中，测试用例所能覆盖的指令共有57 = 22 + 35条指令。其中22是TinyMIPS工程已经实现的指令条数，35是尚未实现的指令数目，其中涉及一些基础的运算指令，也包括了乘除法指令等。

MIPS指令集中提供了32个通用寄存器，其中0号寄存器被硬编码为0。在MIPS中，通用寄存器的字长为32位。除此之外，MIPS中PC寄存器，指示指令地址；HI/LO寄存器，用于存放乘除法指令集的结果；CP0寄存器，一组用于中断，异常等控制的寄存器。在目前的TinyMIPS中，由于尚未实现乘除法指令和中断异常相关的处理，所以暂时没有HI/LO和CP0这些寄存器，后续实现这部分功能时，需要自己添加相关的部件。

> 0号寄存器恒为0，这点的含义其实可以理解为，0号寄存器读取时其结果恒为0，基于这一点，其实可以有多种实现方式实现0号寄存器恒为0的特性

?> TinyMIPS的代码中，是如何保证0号寄存器恒为0这一点的。

MIPS的一大特点就是延迟槽（写在名字的那种）。在采用流水线处理器的CPU当中，往往无法取指阶段就立即判断出下一条指令是否需要进行跳转。为此，早期的设计者们采用了这种称为延迟槽的技术。其方法是，在分支指令的后面，插入一条指令，这条指令无论分支是否发生，都一定会被处理器执行。这条指令的选择依赖于编译器，编译器会分析指令间的相关性，然后在分支指令的后面插入一条无关的指令。这种做法要求比较复杂的编译器技术，所以很多时候会考虑直接插入NOP指令。在处理器技术发展的早期，延迟槽技术确实为处理器带来了一定的性能提升，但是随着处理器技术的发展，超标量技术，分支预测技术等的逐渐成熟，延迟槽技术逐渐鸡肋了起来，它将微架构层面的东西，过度暴露到了ISA层面，新兴指令集诸如RISC-V已经不再采用延迟槽技术。

###　MIPS汇编——以测试用例为例

汇编语言是直接控制硬件的语言，他直接描述了CPU应当如何运行，习惯了高级语言的同学们可能会觉得汇编很难，但是他的复杂性事实上是因为它本身实在是过于简单。对于高级语言中，我们知道有变量，变量之间可以运算，我们可以通过创建各种类型的变量去操作数据，可以通过各种控制流结构组织代码。但是对于实际的硬件来说，它所知道的内容只有内存与寄存器。那么在汇编语言是如何与高级语言中的代码关联起来的呢


#### 基本运算

对于一个简单的`c = a + b`运算，汇编要如何实现呢？首先，a,b都是内存中的变量，MIPS作为Load-Store结构，需要将数据从内存中加载到寄存器堆当中，然后将运算的结果存入内存中c变量所在的地址。

```cpp
int a,b,c;

int main(){
	c = a + b;
	return 0;
}
```
对于这样一段代码，其MIPS编译的结果是
```assmebly
.data


.text
	...
	ld $8, a
	ld $9, b
	add $10, $9, $8
	sd $10, c
	...
```


> 可以动手试试看，如果把其中的a,b,c的声明都放在main函数当中，编译得到的程序会有什么区别。
#### Instructions and Directives


